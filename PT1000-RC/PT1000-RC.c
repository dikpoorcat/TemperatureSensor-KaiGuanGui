/*===========================================================================
公司 ：杭州方诚电力技术有限公司
作者 ：杜颖成
功能：PT1000-RC温度采集功能函数实现
日期：2016.12.21
修订：2018.01.09  程序语法优化，压缩了代码空间
修订：2018.11.23  PT1000_getTempValue仅获取到正确温度时返回1，错误代码、超量程、采样失败等都返回0。
===========================================================================*/
#include "PT1000-RC.h"

const float PT1000FD[][10]=
{
	763.278,767.263,771.247,775.229,779.210,783.189,787.166,791.143,795.117,799.091,    //-60   i=0
    803.063,807.033,811.003,814.970,818.937,822.902,826.865,830.828,834.789,838.748,    //-50   i=1
    842.707,846.664,850.619,854.573,858.526,862.478,866.428,870.377,874.325,878.272,    //-40   i=2
    882.217,886.161,890.103,894.044,897.985,901.923,905.861,909.798,913.733,917.666,    //-30   i=3
    921.599,925.531,929.460,933.390,937.317,941.244,945.170,949.094,953.016,956.938,    //-20   i=4
    960.859,964.779,968.697,972.614,976.529,980.444,984.358,988.270,992.181,996.091,    //-10   i=5
    1000.00,1003.91,1007.81,1011.72,1015.62,1019.53,1023.43,1027.33,1031.23,1035.13,	//0     i=6
    1039.03,1042.92,1046.82,1050.71,1054.60,1058.49,1062.38,1066.27,1070.16,1074.05,	//10    i=7
    1077.94,1081.82,1085.70,1089.59,1093.47,1097.35,1101.23,1105.10,1108.98,1112.86,	//20    i=8
    1116.73,1120.60,1124.47,1128.35,1132.21,1136.08,1139.95,1143.82,1147.68,1151.55,    //30    i=9
    1155.41,1159.27,1163.13,1166.99,1170.85,1174.70,1178.56,1182.41,1186.27,1190.12,    //40    i=10
    1193.97,1197.82,1201.67,1205.52,1209.36,1213.21,1217.05,1220.90,1224.74,1228.58,    //50    i=11
    1232.42,1236.26,1240.09,1243.93,1247.77,1251.60,1255.43,1259.26,1263.09,1266.92,    //60    i=12
    1270.75,1274.58,1278.40,1282.23,1286.05,1289.87,1293.70,1297.52,1301.33,1305.15,    //70    i=13
    1308.97,1312.78,1316.60,1320.41,1324.22,1328.03,1331.84,1335.65,1339.46,1343.26,    //80    i=14
    1347.07,1350.87,1354.68,1358.48,1362.28,1366.08,1369.87,1373.67,1377.47,1381.26,    //90    i=15
    1385.06,1388.85,1392.64,1396.43,1400.22,1404.00,1407.79,1411.58,1415.36,1419.14,    //100   i=16
    1422.93,1426.71,1430.49,1434.26,1438.04,1441.82,1445.59,1449.37,1453.14,1456.91,    //110   i=17
    1460.68,1464.45,1468.22,1471.98,1475.75,1479.51,1483.28,1487.04,1490.80,1494.56,    //120   i=18
    1498.32,1502.08,1505.83,1509.59,1513.34,1517.10,1520.85,1524.60,1528.65,1532.10,    //130   i=19
    1535.84,1539.59,1543.33,1547.08,1550.82,1554.56,1558.30,1562.04,1565.78,1569.52,    //140   i=20
    1573.25,1576.99,1580.72,1584.45,1588.18,1591.91,1595.64,1599.37,1603.09,1606.82,    //150   i=21
    1610.54,1614.27,1617.99,1621.71,1625.43,1629.15,1632.86,1636.58,1640.30,1644.01,    //160   i=22
    1647.72,1651.43,1655.14,1658.85,1662.56,1666.27,1669.97,1673.68,1677.38,1681.08,    //170   i=23
    1684.78,1688.48,1692.18,1695.88,1699.58,1703.27,1706.96,1710.66,1714.35,1718.04,    //180   i=24
    1721.73,1725.42,1729.10,1732.79,1736.48,1740.16,1743.84,1747.52,1751.20,1754.88,    //190   i=25
    1758.56,1762.24,1765.91,1769.59,1773.26,1776.93,1780.60,1784.27,1787.94,1791.61,    //200   i=26
    1795.28,1798.94,1802.60,1806.27,1809.93,1813.59,1817.25,1820.91,1824.56,1828.22,    //210   i=27
    1831.88,1835.53,1839.18,1842.83,1846.48,1850.13,1853.78,1857.43,1861.07,1864.72,    //220   i=28
    1868.36,1872.00,1875.64,1879.28,1882.92,1886.56,1890.19,1893.83,1897.46,1901.10,    //230   i=29
    1904.73,1908.36,1911.99,1915.62,1919.24,1922.87,1926.49,1930.12,1933.74,1937.36,    //240   i=30
    1940.98,1944.60,1948.22,1951.83,1955.45,1959.06,1962.68,1966.29,1969.90,1973.51,    //250   i=31
    1977.12,1980.73,1984.33,1987.94,1991.54,1995.14,1998.75,2002.35,2005.95,2009.54,    //260   i=32
    2013.14,2016.74,2020.33,2023.93,2027.52,2031.11,2034.70,2038.29,2041.88,2045.46,    //270   i=33
    2049.05,2052.63,2056.22,2059.80,2063.38,2066.96,2070.54,2074.11,2077.69,2081.27,    //280   i=34
//    2084.84,2088.41,2091.98,2095.55,2099.12,2102.69,2106.26,2109.82,2113.39,2116.95,    //290   i=35
//    2120.52,2124.08,2127.64,2131.20,2134.75,2138.31,2141.87,2145.42,2148.97,2152.52     //300   i=36
};

//static uint16_t    T_ref=0;
//static uint16_t    T_x=0;
static uint32_t    T_ref0=0;
static uint32_t    T_x0=0;

/***************************************************
函数：INT8U PT1000_getTempValue(INT16U *TempBuff)
功能：测量TP1000温度，存入INT16U *TempBuff
入参：无
出参：返回1时，表示正确，超量程、初始化失败等都返回0。
***************************************************/
INT8U PT1000_getTempValue(INT16U *TempBuff)
{
    uint8_t     i,j,k=0;
    uint16_t    Rref=1000;
    static float   T=0;
    uint16_t    T_U16=0;			//10倍温度，负数0xf800，正数0x0000形式
    static float Rx=0;			//静态局部变量

    PT1000_Initial();				//休眠后需要重新开时钟，因此直接放这里，不在main初始化

//*****************************************************
	//采样舍弃 r x
	Sampling_Res(R_REF);
	Sampling_Res(R_PT1000);
	T_ref0=0;
	T_x0=0;
//=====================================================
	//采样1   r x
	Sampling_Res(R_REF);
	Sampling_Res(R_PT1000);
    //加喂狗
	Feed_Watchdog();								//看门狗喂狗
//=====================================================
	//采样2   x r
	Sampling_Res(R_PT1000);
	Sampling_Res(R_REF);
//=====================================================
	//采样+1  r x
	#if 1   //增加精度
	Sampling_Res(R_REF);
	Sampling_Res(R_PT1000);
	#endif
//=====================================================
	//采样3   x r
	Sampling_Res(R_PT1000);
	Sampling_Res(R_REF);
    //加喂狗
	Feed_Watchdog();								//看门狗喂狗
//采样结束
//*****************************************************

    //PT1000开路（或温度高到捕获超时）时
    if(T_x0==0)     //定时器捕获超时将返回0
    {
        if(T_ref0==0)     //两个电阻都捕获超时，说明大概率是内部比较器失效
        {
            *TempBuff=0x0FA5;   //4005
            return 0;
        }
        *TempBuff=0x0FA1;   //4001
        return 0;
    }

    //PT1000短路时
    if(T_x0<20000)    //定时器捕获的值小于20000认为此电阻短路（真正短路时约3000多）
    {
        *TempBuff=0x0FA2;   //4002
        return 0;
    }

    //参考电阻开路时
    if(T_ref0==0)     //定时器捕获超时将返回0
    {
        *TempBuff=0x0FA3;   //4003
        return 0;
    }

    //参考电阻短路时
    if(T_ref0<20000)    //定时器捕获的值小于20000认为此电阻短路（真正短路时约3000多）
    {
        *TempBuff=0x0FA4;   //4004
        return 0;
    }



    //计算PT1000阻值
    Rx=(float)T_x0/(float)T_ref0;
    Rx=Rref*Rx;


#if 0

    //高温超量程时
    if(Rx>2152.52)    //此时T=3.1446027833E+3
    {
        *TempBuff=0x0C4E;   //3150
        return 0;
    }

    //低温超量程时
    if(Rx<807)    //807时T=-4.9999996944E+2
    {
        *TempBuff=0xF9F4;   //-500
        return 0;
    }

    //T=Calculate_TEMP(T_x,T_ref);				//公式法，算力不足
    for(i=1;i<36;i++)
    {
        if(PT1000FD[i][0]>Rx) break;
    }
    i--;
    for(j=1;j<10;j++)
    {
        if(PT1000FD[i][j]>Rx) break;
    }
    j--;

    //细分
    T=(PT1000FD[i][j+1]-PT1000FD[i][j])/10;     //T为当前每0.1度对应的阻值
    k=(Rx-PT1000FD[i][j])/T;                    //k个0.1度

    //温度数据处理
    T=100*(i-5)+10*j+1*k;                       //温度计算（10倍于实际温度，与DS18B20统一）
    T=T*350/343.7;                              //温度校正，整个量程内，实测值会偏小6.3度左右
	
#else
    //高温超量程时
//    if(Rx>2097.5)    							//因为后面有温度校正步骤所以实际量程上限T=(299/1.0182)-0.11=293.55（温度校正公式反着求）	此时查表估算Rx=2097.5  如果不修改会出现299.几 三百零几.几等量程外异常温度
//	{
//        *TempBuff=0x0BB8;   					//修改为3000
//        return 0;
//    }
    if(Rx>2065.92)    							//因为后面有温度校正步骤所以实际量程上限T=(290/1.0182)-0.11=284.71（温度校正公式反着求）	此时查表估算Rx=2065.92
	{
        *TempBuff=0x0B54;   					//修改为2900
        return 0;
    }

    //低温超量程时
    if(Rx<767.263)    							//因为后面有温度校正步骤所以实际量程下限T=(-60/1.0182)-0.11=-59.04（温度校正公式反着求）  此时查表估算Rx=767.263    如果不修改会出现-60以下等量程外异常温度
    {
        *TempBuff=0xFA58;   					//修改为-600
        return 0;
    }

	//查表法
    for(i=1;i<36;i++)
    {
        if(PT1000FD[i][0]>Rx) break;
    }
    i--;
    for(j=1;j<10;j++)
    {
        if(PT1000FD[i][j]>Rx) break;
    }
    j--;

    //细分
    T=(PT1000FD[i][j+1]-PT1000FD[i][j])/10;     //T为当前每0.1度对应的阻值    //当i=35 j=9时PT1000FD[i][j+1]不存在
    k=(Rx-PT1000FD[i][j])/T;                    //k个0.1度

    //温度数据处理
    T=100*(i-6)+10*j+1*k;                       //温度计算（10倍于实际温度，与DS18B20统一） 						//增加-60--50量程后，i-5修改成i-6

	T=1.0182*(T+0.11);							//3.3V tvs						温度校正公式修改
#endif
	
	
	
    if(T<0)
    {
        T=0-T;                                  //转换为正数
        T_U16=(uint16_t)T;
        T_U16|=0xf800;                          //转换成与DS18B20统一的负数表示形式
		if(T_U16==0xf800)T_U16=0x0000;     		 //避免-0.0度r@示6438.8
    }
    else T_U16=(uint16_t)T;
    *TempBuff=T_U16;                            //存入INT16U *TempBuff

    TIM2_Cmd(DISABLE);

    return 1;
}

/***************************************************
函数：void Sampling_Res(INT8U res)
功能：对参考电阻阻值采样，通过入参选择采样电阻。
入参：INT8U res，1时，参考电阻；0时PT1000。
出参：无
***************************************************/
void Sampling_Res(INT8U res)
{
  	uint8_t  	retry;
	uint16_t	T_temp=0;
	
	for(retry=0;retry<3;retry++)
	{
		T_temp=Value_Res(res);
		if(T_temp) break;
	}
	
	if(res)		//res=R_REF时，参考电阻（R_REF==1）
	{
		T_ref0 = T_ref0 + T_temp;			//保存测量值
	}else		//res=R_PT1000时，PT1000电阻（R_PT1000==0）
	{
		T_x0=T_x0+T_temp;					//保存测量值
	}	
}

/***************************************************
函数：uint16_t Value_Res(INT8U res)
功能：测量并返回电阻的放电时间，通过入参选择放电电阻。
入参：INT8U res，1时，参考电阻；0时PT1000。
出参：Rref的放电时间
***************************************************/
uint16_t Value_Res(INT8U res)
{
    uint16_t t=0;
    uint16_t captureValue=0;

    //TIM2 configuration
    TIM2_Config();          //重新初始化

    //充电过程
    GPIO_Init(PORT_Rref, PIN_Rref, GPIO_Mode_Out_PP_High_Slow);     //从Rref充电
    GPIO_Init(PORT_Rx, PIN_Rx, GPIO_Mode_Out_PP_High_Slow);         //从Rx充电
    Delay_10Ms(10);                         //5T~7T

	if(res)		//res=R_REF时，参考电阻（R_REF==1）
	{
		//闲置引脚高阻处理
		GPIO_Init(PORT_Rx, PIN_Rx, GPIO_Mode_In_FL_No_IT);			//测参考电阻时，PT1000闲置
		
		//Rref放电过程
		PORT_Rref->ODR &= ~PIN_Rref;								//从Rref放电//GPIO_Init(PORT_Rref, PIN_Rref, GPIO_Mode_Out_PP_Low_Slow);		
	}else		//res=R_PT1000时，PT1000电阻（R_PT1000==0）
	{
		//闲置引脚高阻处理
		GPIO_Init(PORT_Rref, PIN_Rref, GPIO_Mode_In_FL_No_IT);		//测PT1000时，参考电阻闲置
		
		//Rx放电过程
		PORT_Rx->ODR &= ~PIN_Rx;									//从Rx放电//GPIO_Init(PORT_Rx, PIN_Rx, GPIO_Mode_Out_PP_Low_Slow);
	}

	TIM2->CR1 |= TIM_CR1_CEN;				//TIM2开始计时，向上增长//TIM2_Cmd(ENABLE);
	
    //等待放电完成并读取放电时间
    while((TIM2->SR1 & 0x04)==0)			//等待TIM2_SR寄存器的CC2IF被置位（定时器捕获成功）
    {
        t++;
        if(t==5000)							//4.7uf，2000足够
        {
            //加喂狗
			Feed_Watchdog();				//看门狗喂狗
            return 0;						//捕获超时
        }
    }
    TIM2_Cmd(DISABLE);						//关闭定时器
    captureValue=TIM2_GetCapture2();        //放电时间t（读取会自动清空CCiIF）
    return captureValue;					//返回TIM2_GetCapture2()
}

/***************************************************
函数：void PT1000-RC_Initial(void)
功能：PT1000初始化
入参：无
出参：无
***************************************************/
void PT1000_Initial(void)
{
    /* CLK configuration -------------------------------------------*/
    CLK_Config();               //COMP和TIM2时钟
    /* COMP configuration -------------------------------------------*/
    COMP_Config();              //比较器参数配置
	//COM 引脚初始化（其他两引脚驱动中有初始化）
	GPIO_Init(GPIOD, GPIO_Pin_0, GPIO_Mode_In_FL_No_IT);
}

/***************************************************
函数：static void CLK_Config(void)
功能：时钟初始化
入参：无
出参：无
***************************************************/
static void CLK_Config(void)
{
  /* Enable COMP clock */
  CLK_PeripheralClockConfig(CLK_Peripheral_COMP, ENABLE);
  /* Enable TIM2 clock */
  CLK_PeripheralClockConfig(CLK_Peripheral_TIM2, ENABLE);
}

/***************************************************
函数：static void COMP_Config(void)
功能：比较器初始化
入参：无
出参：无
***************************************************/
static void COMP_Config(void)
{
  /* Close I/O Switch 23 to select PD0 as comparator 2 non inverting input:
     External signal should be connected to PD0 */
  SYSCFG_RIIOSwitchConfig(RI_IOSwitch_23, ENABLE);

  /* Init COMP2: VREFINT is used as COMP2 inverting input
                COMP2 output is connected to TIM2 input capture 2 (default configuration)
                COMP2 speed is fast */
  COMP_Init(COMP_InvertingInput_1_4VREFINT, COMP_OutputSelect_TIM2IC2, COMP_Speed_Fast);

  /* COMP2 edge detection: rising edge */
  COMP_EdgeConfig(COMP_Selection_COMP2, COMP_Edge_Falling);     //RC放电，所以下降沿触发

  COMP_ITConfig(COMP_Selection_COMP2,DISABLE);
}

/***************************************************
函数：static void TIM2_Config(void)
功能：定时器2初始化
入参：无
出参：无
***************************************************/
static void TIM2_Config(void)
{
    //TIM2初始化
        TIM2_TimeBaseInit(TIM2_Prescaler_1,TIM2_CounterMode_Up,0xFFFF);     //0xFFFF=Auto-reload register high (TIM1_ARRH)

        //输入捕获初始化
        TIM2_ICInit(TIM2_Channel_2,TIM2_ICPolarity_Falling,TIM2_ICSelection_DirectTI,TIM2_ICPSC_DIV1,0x05);  //0x00是输入捕获滤波器 TIM2_ICPolarity_Rising

        /* Enable CC2 interrupt request */
        TIM2_ITConfig(TIM2_IT_CC2, DISABLE);   //ENABLE
        //enableInterrupts();
        TIM2_SetCounter(0);
  /* Enable TIM2 */
  //TIM2_Cmd(ENABLE);
}
